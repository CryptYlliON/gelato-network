import { task } from "@nomiclabs/buidler/config";
import { defaultNetwork } from "../../../../../buidler.config";
import { utils } from "ethers";

export default task(
  "gc-registerprovider",
  `Sends tx and <ethamount> to GelatoCore.registerProvider(gelatoExecutor, modules[]) on [--network] (default: ${defaultNetwork})`
)
  .addPositionalParam("ethamount", "The amount of ETH to provide")
  .addVariadicPositionalParam("modules", "The provider modules")
  .addOptionalParam("gelatoexecutor", "The provider's assigned gelatoExecutor")
  .addOptionalParam(
    "providerindex",
    "index of user account generated by mnemonic to fetch provider address",
    2,
    types.int
  )
  .addOptionalParam(
    "executorfeeceil",
    "Upper Limit for executorSuccessShare",
    5,
    types.int
  )
  .addOptionalParam(
    "oraclefeeceil",
    "Upper Limit for gasAdminSuccessShare",
    2,
    types.int
  )
  .addOptionalParam("gelatocoreaddress")
  .addFlag("events", "Logs parsed Event Logs to stdout")
  .addFlag("log", "Logs return values to stdout")
  .setAction(async taskArgs => {
    try {
      // Gelato Provider is the 3rd signer account
      const {
        [taskArgs.providerindex]: gelatoProvider
      } = await ethers.signers();

      taskArgs.gelatoexecutor = await run("handleGelatoExecutor", {
        gelatoexecutor: taskArgs.gelatoexecutor
      });

      const gelatoCore = await run("instantiateContract", {
        contractname: "GelatoCore",
        contractaddress: taskArgs.gelatocoreaddress,
        signer: gelatoProvider,
        write: true
      });

      if (taskArgs.log) console.log("gc-registerprovider:\n", taskArgs);

      // GelatoCore contract call from provider account
      const tx = await gelatoCore.registerProvider(
        taskArgs.gelatoexecutor,
        taskArgs.modules,
        taskArgs.executorfeeceil,
        taskArgs.oraclefeeceil,
        {
          value: utils.parseEther(taskArgs.ethamount)
        }
      );

      if (taskArgs.log) console.log(`\n\ntxHash registerProvider: ${tx.hash}`);
      const { blockHash: blockhash } = await tx.wait();

      if (taskArgs.events) {
        await run("event-getparsedlogsallevents", {
          contractname: "GelatoCore",
          contractaddress: gelatoCore.address,
          blockhash,
          txhash: tx.hash,
          log: true
        });
      }

      return tx.hash;
    } catch (error) {
      console.error(error, "\n");
      process.exit(1);
    }
  });
